@using PicklePlay.Models.ViewModels
@using PicklePlay.Models
@using System.Text
@model DrawEliminationViewModel
@{
    // --- *** NEW: DYNAMIC BRACKET SIZE LOGIC *** ---
    int bracketSize;
    if (Model.TotalSeeds <= 8)
    {
        bracketSize = 8;
    }
    else
    {
        // Calculate the next power of 2
        bracketSize = (int)Math.Pow(2, Math.Ceiling(Math.Log(Model.TotalSeeds, 2)));
    }
    // Ensure bracket size doesn't exceed 64 (based on your seeding dictionary)
    if (bracketSize > 64) bracketSize = 64;
    // --- *** END OF NEW LOGIC *** ---
    
    // --- Create team lookup dictionary ---
    var teamLookup = Model.Teams.Where(t => t.BracketSeed.HasValue).ToDictionary(t => t.BracketSeed!.Value, t => t);
    
    // --- Standard seeding orders ---
    Dictionary<int, int[]> seeding = new Dictionary<int, int[]>
    {
        { 8, new[] { 1, 8, 4, 5, 3, 6, 2, 7 } },
        { 16, new[] { 1, 16, 8, 9, 5, 12, 4, 13, 6, 11, 3, 14, 7, 10, 2, 15 } },
        { 32, new[] { 1, 32, 17, 16, 9, 24, 25, 8, 5, 28, 21, 12, 13, 20, 
                29, 4, 3, 30, 19, 14, 11, 22, 27, 6, 7, 26, 23, 10, 15, 18, 31, 2 } },
        { 64, new int[64] }
    };
    var seeds = seeding.GetValueOrDefault(bracketSize) ?? new int[bracketSize];
    if (bracketSize == 64 && seeds[0] == 0)
    {
        for(int i = 0; i < 32; i++) { seeds[i*2] = i+1; seeds[i*2+1] = 64-i; }
    }

    // --- Build JSON string manually for bracket data ---
    var teamPairs = new List<string>();
    for (int i = 0; i < seeds.Length; i += 2)
    {
        var team1 = teamLookup.GetValueOrDefault(seeds[i]);
        var team2 = teamLookup.GetValueOrDefault(seeds[i + 1]);
        
        string team1Json;
        if (team1 != null) 
        { 
            var escapedName = team1.TeamName.Replace("\"", "\\\"").Replace("\\", "\\\\");
            team1Json = $"\"{escapedName}\""; 
        }
        else if (seeds[i] <= Model.TotalSeeds) 
        { 
            team1Json = $"\"Seed {seeds[i]}\""; 
        }
        else 
        { 
            team1Json = "\"BYE\""; 
        }
        
        string team2Json;
        if (team2 != null) 
        { 
            var escapedName = team2.TeamName.Replace("\"", "\\\"").Replace("\\", "\\\\");
            team2Json = $"\"{escapedName}\""; 
        }
        else if (seeds[i + 1] <= Model.TotalSeeds) 
        { 
            team2Json = $"\"Seed {seeds[i + 1]}\""; 
        }
        else 
        { 
            team2Json = "\"BYE\""; 
        }

        teamPairs.Add($"[{team1Json},{team2Json}]");
    }
    
    var firstRoundResults = string.Join(",", Enumerable.Repeat("[]", teamPairs.Count));
    string bracketDataJson = $"{{\"teams\":[{string.Join(",", teamPairs)}], \"results\":[[{firstRoundResults}]]}}";
    
    // --- Correct Round Header Logic ---
    int rounds = (int)Math.Log(bracketSize, 2);
    var roundHeaders = new List<string>();
    for (int r = 0; r < rounds; r++)
    {
        int teamsInRound = (int)Math.Pow(2, rounds - r);
        if (teamsInRound == 2) roundHeaders.Add("Final");
        else if (teamsInRound == 4) roundHeaders.Add("Semi-Finals");
        else if (teamsInRound == 8) roundHeaders.Add("Quarter-Finals");
        else roundHeaders.Add("Round of " + teamsInRound);
    }
    
    var jsonOptions = new System.Text.Json.JsonSerializerOptions
    {
        WriteIndented = false
    };
    string roundHeadersJson = System.Text.Json.JsonSerializer.Serialize(roundHeaders, jsonOptions);
}

<style>
    .round-header {
        font-weight: bold;
        text-align: center;
        margin-bottom: 10px;
        font-size: 1.1rem;
        color: #333;
    }
    /* --- ADD THIS NEW STYLE --- */
    .bracket-container {
        width: 100%;
        overflow: auto; /* This adds scrollbars if needed */
        min-height: 600px; /* Gives the bracket space */
        border: 1px solid #ddd;
        background-color: #fcfcfc;
    }
    #thirdPlaceContainer .card {
    max-width: 500px;
    margin: 0 auto;
}

#thirdPlaceContainer .bi-trophy-fill {
    font-size: 1.2rem;
    animation: trophy-glow 2s ease-in-out infinite;
}

</style>

<h5 class="mb-3">Published Bracket (@bracketSize Teams)</h5>
<div id="bracketVisual_Published" style="width: 100%; overflow: auto; min-height: 600px; border: 1px solid #ddd; background-color: #fcfcfc;"></div>

<!-- Third place small panel -->
<div id="thirdPlaceContainer" class="mt-3" style="min-height:56px;"></div>

<!-- Store data in data attributes instead of inline script -->
<div id="bracket-data-holder" 
     data-schedule-id="@Model.ScheduleId"
     data-bracket='@Html.Raw(bracketDataJson)'
     data-headers='@Html.Raw(roundHeadersJson)'
     data-third-place="@Model.HasThirdPlaceMatch.ToString().ToLower()"
     style="display:none;">
</div>

<script>
(function() {
    console.log('_ViewDrawElimination script executing (robust 3rd-place)...');

    var dataHolder = document.getElementById('bracket-data-holder');
    if (!dataHolder) { console.error('ERROR: bracket-data-holder not found!'); return; }

    var scheduleId = dataHolder.getAttribute('data-schedule-id');
    if (!scheduleId) { console.error('ERROR: data-schedule-id not found on bracket-data-holder!'); return; }

    function fetchAndRender() {
        fetch('/Match/GetBracketData?scheduleId=' + scheduleId)
            .then(r => r.json())
            .then(data => {
                console.log('BRACKET API RESPONSE (full):', data);
                renderFull(data);
            })
            .catch(err => console.error('Error fetching bracket:', err));
    }

    function renderFull(response) {
    var container = document.getElementById('bracketVisual_Published');
    if (!container) { console.error('No bracket container'); return; }

    try {
        if (typeof $ !== 'undefined' && typeof $.fn.bracket === 'function') {
            $(container).empty();
            $(container).bracket({
                init: response.bracketData,
                teamWidth: 170,
                scoreWidth: 30,
                roundMargin: 40,
                skipConsolationRound: false
            });
            console.log('Bracket rendered successfully!');
        } else {
            container.innerHTML = '<pre>' + JSON.stringify(response.bracketData, null, 2) + '</pre>';
        }
    } catch (err) {
        console.error('Bracket plugin failed:', err);
        container.innerHTML = '<div class="alert alert-danger">Could not render bracket. ' + err.message + '</div>';
    }

    // ===== IMPROVED THIRD PLACE RENDERING =====
    var thirdEl = document.getElementById('thirdPlaceContainer');
    if (!thirdEl) {
        console.warn('thirdPlaceContainer not found - creating one');
        thirdEl = document.createElement('div');
        thirdEl.id = 'thirdPlaceContainer';
        thirdEl.className = 'mt-3';
        thirdEl.style.minHeight = '56px';
        container.insertAdjacentElement('afterend', thirdEl);
    }
    thirdEl.style.display = 'block';

    if (response && response.thirdPlace) {
        var tp = response.thirdPlace;
        console.log('Third place data:', tp);

        // Determine winner index (handle 0 explicitly)
        var winnerIndex = null;
        if (tp.winnerIndex !== undefined && tp.winnerIndex !== null) {
            winnerIndex = Number(tp.winnerIndex);
        }

        console.log('Winner index after parsing:', winnerIndex);

        var team1Name = tp.team1 || 'TBD';
        var team2Name = tp.team2 || 'TBD';
        
        // Build team display with winner highlighting
        var team1Class = (winnerIndex === 0) ? 'fw-bold text-success' : '';
        var team2Class = (winnerIndex === 1) ? 'fw-bold text-success' : '';
        
        var team1Display = '<span class="' + team1Class + '">' + team1Name;
        if (winnerIndex === 0) team1Display += ' <i class="bi bi-trophy-fill text-warning"></i>';
        team1Display += '</span>';
        
        var team2Display = '<span class="' + team2Class + '">' + team2Name;
        if (winnerIndex === 1) team2Display += ' <i class="bi bi-trophy-fill text-warning"></i>';
        team2Display += '</span>';

        // Build the card
        var cardHTML = '<div class="card shadow-sm">' +
            '<div class="card-header bg-secondary text-white d-flex justify-content-between align-items-center">' +
            '<strong><i class="bi bi-award-fill me-2"></i>3rd Place Match</strong>';
        
        if (tp.status) {
            var statusBadge = '';
            if (tp.status === 'Done') {
                statusBadge = '<span class="badge bg-success">Completed</span>';
            } else if (tp.status === 'Active' || tp.status === 'Progressing') {
                statusBadge = '<span class="badge bg-warning text-dark">' + tp.status + '</span>';
            } else {
                statusBadge = '<span class="badge bg-light text-dark">' + tp.status + '</span>';
            }
            cardHTML += statusBadge;
        }
        
        cardHTML += '</div><div class="card-body">' +
            '<div class="d-flex justify-content-around align-items-center">' +
            '<div class="text-center" style="flex: 1;">' + team1Display + '</div>' +
            '<div class="text-muted fw-bold">VS</div>' +
            '<div class="text-center" style="flex: 1;">' + team2Display + '</div>' +
            '</div>';
        
        // Add winner announcement if there is one
        if (winnerIndex === 0 || winnerIndex === 1) {
            var winnerName = (winnerIndex === 0) ? team1Name : team2Name;
            cardHTML += '<hr class="my-2">' +
                '<div class="text-center text-success">' +
                '<strong><i class="bi bi-trophy-fill text-warning me-1"></i>3rd Place: ' + winnerName + '</strong>' +
                '</div>';
        }
        
        cardHTML += '</div></div>';

        thirdEl.innerHTML = cardHTML;
        console.log('Third place match rendered with winner:', (winnerIndex === 0) ? team1Name : (winnerIndex === 1) ? team2Name : 'No winner yet');
    } else {
        thirdEl.innerHTML = '';
        thirdEl.style.display = 'none';
        console.log('No third-place match to render.');
    }
}

    // initial + polling
    fetchAndRender();
    var poll = setInterval(fetchAndRender, 5000);
    window.stopBracketPolling = function() { clearInterval(poll); };
})();
</script>